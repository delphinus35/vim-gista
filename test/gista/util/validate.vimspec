let s:V = vital#of('vital')
let s:F = s:V.import('System.File')
let s:P = s:V.import('System.Filepath')
let s:S = s:V.import('Vim.ScriptLocal')
let s:sf = s:S.sfuncs(s:P.realpath(
      \ 'autoload/gista/util/validate.vim'
      \))
let s:sv = s:S.svars(s:P.realpath(
      \ 'autoload/gista/util/validate.vim'
      \))

Describe gista#util#validate
  Before
    let saved_NAME = s:sv.NAME
    let s:sv.NAME = 'unittest'
  End
  After
    let s:sv.NAME = saved_NAME
  End

  Context [PRIVATE] s:throw({msg})
    It throw unittest: ValidationError: {msg}
      let sf = s:sf
      Throw /^unittest: ValidationError: foo$/ sf.throw('foo')
    End
  End
  Context [PRIVATE] s:translate({text}, {table})
    It substitutes keys of {table} in {text} into string value of {table}
      let text = 'foo %foo bar %bar'
      let table = {
            \ '%foo': 'Hello',
            \ '%bar': 'World',
            \}
      let ret = s:sf.translate(text, table)
      Assert Equals(ret, 'foo Hello bar World')
    End
    It substitutes keys of {table} in {text} into non string value of {table}
      let text = 'foo %foo bar %bar'
      let table = {
            \ '%foo': ['Hello'],
            \ '%bar': {'World': 'World'},
            \}
      let ret = s:sf.translate(text, table)
      Assert Equals(ret, 'foo [''Hello''] bar {''World'': ''World''}')
    End
  End

  Context #exists({value}, {list}[, {msg}])
    It does nothing if {value} is in {list}
      call gista#util#validate#exists('foo', ['foo', 'bar'])
    End
    It throw ValidationError if {value} is not in {list}
      let value = 'unknown'
      let list = ['foo', 'bar']
      Throw /ValidationError/ gista#util#validate#exists(value, list)
    End
    It throw ValidationError with {msg} if {value} is not in {list}
      let value = 'unknown'
      let list = ['foo', 'bar']
      Throw /ValidationError: unknown \['foo', 'bar'\]$/
            \ gista#util#validate#exists(value, list, '%value %list')
    End
  End
  Context #not_exists({value}, {list}[, {msg}])
    It does nothing if {value} is NOT in {list}
      call gista#util#validate#not_exists('foo', ['bar'])
    End
    It throw ValidationError if {value} is in {list}
      let value = 'foo'
      let list = ['foo', 'bar']
      Throw /ValidationError/ gista#util#validate#not_exists(value, list)
    End
    It throw ValidationError with {msg} if {value} is not in {list}
      let value = 'foo'
      let list = ['foo', 'bar']
      Throw /ValidationError: foo \['foo', 'bar'\]$/
            \ gista#util#validate#not_exists(value, list, '%value %list')
    End
  End

  Context #key_exists({value}, {dict}[, {msg}])
    It does nothing if {value} is in {dict}
      call gista#util#validate#key_exists('foo', {'foo': 'bar'})
    End
    It throw ValidationError if {value} is not in {dict}
      let value = 'unknown'
      let dict = {'foo': 'bar'}
      Throw /ValidationError/ gista#util#validate#key_exists(value, dict)
    End
    It throw ValidationError with {msg} if {value} is not in {dict}
      let value = 'unknown'
      let dict = {'foo': 'bar'}
      Throw /ValidationError: unknown {'foo': 'bar'}$/
            \ gista#util#validate#key_exists(value, dict, '%value %dict')
    End
  End
  Context #key_not_exists({value}, {dict}[, {msg}])
    It does nothing if {value} is NOT in {dict}
      call gista#util#validate#key_not_exists('hoge', {'foo': 'bar'})
    End
    It throw ValidationError if {value} is in {dict}
      let value = 'foo'
      let dict = {'foo': 'bar'}
      Throw /ValidationError/ gista#util#validate#key_not_exists(value, dict)
    End
    It throw ValidationError with {msg} if {value} is in {dict}
      let value = 'foo'
      let dict = {'foo': 'bar'}
      Throw /ValidationError: foo {'foo': 'bar'}$/
            \ gista#util#validate#key_not_exists(value, dict, '%value %dict')
    End
  End

  Context #empty({value}[, {msg}])
    It does nothing if {value} is an empty value
      call gista#util#validate#empty('')
      call gista#util#validate#empty([])
      call gista#util#validate#empty({})
      call gista#util#validate#empty(0)
    End
    It throw ValidationError if {value} is non empty value
      Throw /ValidationError/ gista#util#validate#empty('foo')
      Throw /ValidationError/ gista#util#validate#empty(['foo'])
      Throw /ValidationError/ gista#util#validate#empty({'foo': 'bar'})
      Throw /ValidationError/ gista#util#validate#empty(1)
    End
    It throw ValidationError with {msg} if {value} is non empty value
      Throw /ValidationError: foo/ gista#util#validate#empty('foo', '%value')
      Throw /ValidationError: \['foo'\]/ gista#util#validate#empty(['foo'], '%value')
      Throw /ValidationError: {'foo': 'bar'}/ gista#util#validate#empty({'foo': 'bar'}, '%value')
      Throw /ValidationError: 1/ gista#util#validate#empty(1, '%value')
    End
  End
  Context #not_empty({value}[, {msg}])
    It does nothing if {value} is not an empty value
      call gista#util#validate#not_empty('foo')
      call gista#util#validate#not_empty(['foo'])
      call gista#util#validate#not_empty({'foo': 'bar'})
      call gista#util#validate#not_empty(1)
    End
    It throw ValidationError if {value} is an empty value
      Throw /ValidationError/ gista#util#validate#not_empty('')
      Throw /ValidationError/ gista#util#validate#not_empty([])
      Throw /ValidationError/ gista#util#validate#not_empty({})
      Throw /ValidationError/ gista#util#validate#not_empty(0)
    End
    It throw ValidationError with {msg} if {value} is an empty value
      Throw /ValidationError: HELLO/
            \ gista#util#validate#not_empty('', 'HELLO')
      Throw /ValidationError: HELLO/
            \ gista#util#validate#not_empty([], 'HELLO')
      Throw /ValidationError: HELLO/
            \ gista#util#validate#not_empty({}, 'HELLO')
      Throw /ValidationError: HELLO/
            \ gista#util#validate#not_empty(0, 'HELLO')
    End
  End

  Context #pattern({value}, {pattern}[, {msg}])
    It does nothing if {value} follow {pattern}
      call gista#util#validate#pattern('foo', '^foo$')
    End
    It throw ValidationError if {value} does not follow {pattern}
      Throw /ValidationError/ gista#util#validate#pattern('bar', '^foo$')
    End
    It throw ValidationError with {msg} if {value} does not follow {pattern}
      Throw /ValidationError: bar \^foo\$/
            \ gista#util#validate#pattern('bar', '^foo$', '%value %pattern')
    End
  End
  Context #not_pattern({value}, {pattern}[, {msg}])
    It does nothing if {value} does not follow {pattern}
      call gista#util#validate#not_pattern('bar', '^foo$')
    End
    It throw ValidationError if {value} follow {pattern}
      Throw /ValidationError/ gista#util#validate#not_pattern('foo', '^foo$')
    End
    It throw ValidationError with {msg} if {value} follow {pattern}
      Throw /ValidationError: foo \^foo\$/
            \ gista#util#validate#not_pattern('foo', '^foo$', '%value %pattern')
    End
  End

  Context #silently({fn}[, {args}, {default}])
    After
      unlet g:ValidateSilentlyTestVariable
      delfunction ValidateSilentlyTestFunction
    End

    It return a result of {fn}
      function ValidateSilentlyTestFunction(...) abort
        let g:ValidateSilentlyTestVariable = a:000
        return { 'Hello': 'Goodbye' }
      endfunction
      let ret = gista#util#validate#silently(
            \ 'ValidateSilentlyTestFunction', ['a']
            \)
      Assert Equals(g:ValidateSilentlyTestVariable, ['a'])
      Assert Equals(ret, { 'Hello': 'Goodbye' })
    End

    It suppress ValidationError in {fn} and return an empty string if it is a valid ValidationError
      function ValidateSilentlyTestFunction(...) abort
        let g:ValidateSilentlyTestVariable = a:000
        throw printf('%s: ValidationError: Test', s:sv.NAME)
        " The following lines are not executed
        let g:ValidateSilentlyTestVariable = []
        return { 'Hello': 'Goodbye' }
      endfunction
      let ret = gista#util#validate#silently(
            \ 'ValidateSilentlyTestFunction', ['a']
            \)
      Assert Equals(g:ValidateSilentlyTestVariable, ['a'])
      Assert Equals(ret, '')
    End

    It suppress ValidationError in {fn} and return {default} if it is a valid ValidationError
      function ValidateSilentlyTestFunction(...) abort
        let g:ValidateSilentlyTestVariable = a:000
        throw printf('%s: ValidationError: Test', s:sv.NAME)
        " The following lines are not executed
        let g:ValidateSilentlyTestVariable = []
        return { 'Hello': 'Goodbye' }
      endfunction
      let ret = gista#util#validate#silently(
            \ 'ValidateSilentlyTestFunction', ['a'], {'Foo': 'Bar'},
            \)
      Assert Equals(g:ValidateSilentlyTestVariable, ['a'])
      Assert Equals(ret, {'Foo': 'Bar'})
    End

    It does not suppress exception in {fn} if it is not a valid ValidationError
      function ValidateSilentlyTestFunction(...) abort
        let g:ValidateSilentlyTestVariable = a:000
        throw 'Foo: ValidationError: Test'
        " The following lines are not executed
        let g:ValidateSilentlyTestVariable = []
      endfunction
      Throw /^Foo: ValidationError: Test$/
            \ gista#util#validate#silently('ValidateSilentlyTestFunction', ['a'])
    End
  End
End

