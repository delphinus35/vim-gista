let s:V = vital#of('vital')
let s:F = s:V.import('System.File')
let s:P = s:V.import('System.Filepath')
let s:S = s:V.import('Vim.ScriptLocal')
let s:sf = s:S.sfuncs(s:P.realpath('autoload/gista/client.vim'))

Describe gista#client
  Before all
    let saved_gista_cachedir = g:gista#cache_dir
    let g:gista#cache_dir = tempname()
  End
  After all
    call s:F.rmdir(g:gista#cache_dir, 'r')
    let g:gista#cache_dir = saved_gista_cachedir
  End
  Context #get({baseurl})
    It return an extended Web.API.GitHub client
      let ret = gista#client#get('https://api.github.com')
      Assert KeyExists(ret, '__super__')
      Assert KeyExists(ret, 'token_cache')
      Assert KeyExists(ret, 'entry_cache')
      Assert KeyExists(ret, 'persistent')
    End

    Context return a client and client.persistent()
      It save token and entry into file and memory cache
        let client = deepcopy(gista#client#get('https://api.github.com'))
        call client.token_cache.set('foo', 'bar')
        call client.entry_cache.set('foo', 'bar')
        let meta = s:sf.get_meta(client.baseurl)
        Assert False(has_key(get(meta, 'token', {}), 'foo'))
        Assert False(has_key(get(meta, 'entry', {}), 'foo'))

        call client.persistent()
        let meta = s:sf.get_meta(client.baseurl)
        Assert True(has_key(get(meta, 'token', {}), 'foo'))
        Assert True(has_key(get(meta, 'entry', {}), 'foo'))
      End
    End
    Context return a client and client.set_token({username}, {token})
      It call client.persistent() internally
        let client = deepcopy(gista#client#get('https://api.github.com'))
        let client.called = 0
        function! client.persistent() abort " {{{
          let self.called = 1
        endfunction " }}}

        call client.set_token('foo', 'bar')
        Assert Equals(client.called, 1)
      End
    End
  End
  Context #get_baseurl({baseurl_or_alias})
    Before
      let saved_gista_baseurl_aliases = g:gista#baseurl_aliases
      let g:gista#baseurl_aliases = {
            \ 'foo': 'bar',
            \}
    End
    After
      let g:gista#baseurl_aliases = saved_gista_baseurl_aliases
    End
    It return {baseurl_or_alias} when it starts from http://
      let ret = gista#client#get_baseurl('http://foo.bar')
      Assert Equals(ret, 'http://foo.bar')
    End
    It return {baseurl_or_alias} when it starts from https://
      let ret = gista#client#get_baseurl('https://foo.bar')
      Assert Equals(ret, 'https://foo.bar')
    End
    It return a url in g:gista#baseurl_aliases when {baseurl_or_alias} is an alias
      let ret = gista#client#get_baseurl('foo')
      Assert Equals(ret, 'bar')
    End
    It return echo error and an empty string when {baseurl_or_alias} seems an alias but not found
      redir => stdout
      let ret = gista#client#get_baseurl('bar')
      redir END
      Assert Equals(ret, '')
      Assert Match(stdout, '^\nNo baseurl alias for')
    End
  End
  Context #get_alias({baseurl_or_alias})
    Before
      let saved_gista_baseurl_aliases = g:gista#baseurl_aliases
      let g:gista#baseurl_aliases = {
            \ 'foo': 'http://foo',
            \ 'bar': 'https://bar',
            \}
    End
    After
      let g:gista#baseurl_aliases = saved_gista_baseurl_aliases
    End
    It return {baseurl_or_alias} when it seems an alias
      let ret = gista#client#get_alias('hello')
      Assert Equals(ret, 'hello')
    End
    It return an alias when {baseurl_or_alias} starts from http:// and found
      let ret = gista#client#get_alias('http://foo')
      Assert Equals(ret, 'foo')
    End
    It return {baseurl_or_alias} when it starts from http:// and NOT found
      let ret = gista#client#get_alias('http://bar')
      Assert Equals(ret, 'http://bar')
    End
    It return an alias when {baseurl_or_alias} starts from https:// and found
      let ret = gista#client#get_alias('https://bar')
      Assert Equals(ret, 'bar')
    End
    It return {baseurl_or_alias} when it starts from https:// and NOT found
      let ret = gista#client#get_alias('https://foo')
      Assert Equals(ret, 'https://foo')
    End
  End
  Context #find_next({res})
    It return 0 when no next page is found in header
      let res = { 'header': [
            \  'Status: 200 OK',
            \  'X-RateLimit-Limit: 5000',
            \  'X-RateLimit-Remaining: 4999',
            \] }
      let ret = gista#client#find_next(res)
      Assert Equals(ret, 0)
      let res = { 'header': [
            \  'Status: 200 OK',
            \  'Link: <{URL}?page=1>; rel="first",<{URL}?page=4>; rel="prev"',
            \  'X-RateLimit-Limit: 5000',
            \  'X-RateLimit-Remaining: 4999',
            \]}
      let ret = gista#client#find_next(res)
      Assert Equals(ret, 0)
    End
    It return a corresponding digit when a next page is found in header
      let res = { 'header': [
            \  'Status: 200 OK',
            \  'Link: <{URL}?page=2>; rel="next",<{URL}?page=5>; rel="last"',
            \  'X-RateLimit-Limit: 5000',
            \  'X-RateLimit-Remaining: 4999',
            \]}
      let ret = gista#client#find_next(res)
      Assert Equals(ret, 2)
    End
  End
  Context #find_last({res})
    It return 0 when no last page is found in header
      let res = { 'header': [
            \  'Status: 200 OK',
            \  'X-RateLimit-Limit: 5000',
            \  'X-RateLimit-Remaining: 4999',
            \] }
      let ret = gista#client#find_last(res)
      Assert Equals(ret, 0)
      let res = { 'header': [
            \  'Status: 200 OK',
            \  'Link: <{URL}?page=1>; rel="first",<{URL}?page=4>; rel="prev"',
            \  'X-RateLimit-Limit: 5000',
            \  'X-RateLimit-Remaining: 4999',
            \]}
      let ret = gista#client#find_last(res)
      Assert Equals(ret, 0)
    End
    It return a corresponding digit when a last page is found in header
      let res = { 'header': [
            \  'Status: 200 OK',
            \  'Link: <{URL}?page=2>; rel="next",<{URL}?page=5>; rel="last"',
            \  'X-RateLimit-Limit: 5000',
            \  'X-RateLimit-Remaining: 4999',
            \]}
      let ret = gista#client#find_last(res)
      Assert Equals(ret, 5)
    End
  End
End
